<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EEG Number Cycler</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #f5f5f5;
      font-family: system-ui, sans-serif;
    }

    .cell {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #b8b8b8;
      border-radius: 12px;
      font-size: 2rem;
      position: absolute;
      transition: background-color 120ms, border 120ms, transform 120ms;
    }

    /* Green outline for “currently lit” */
    .on { border: 4px solid #2ecc71; }

    /* Red fill for “selected” */
    .selected { background-color: #dc1313; color: white; }

    /* Corner placement */
    #box1 { top: 200px; left: 300px; }
    #box2 { top: 200px; right: 300px; }
    #box3 { bottom: 200px; left: 300px; }
    #box4 { bottom: 200px; right: 300px; }

    /* HUD */
    .hud {
      position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
      background: white; padding: 10px 14px; border: 1px solid #ddd; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.08); font-size: 14px; display: flex; gap: 12px; align-items: center;
    }
    .hud label { display:flex; gap:6px; align-items:center; }
    .hud code { background:#f2f2f2; padding:2px 6px; border-radius:6px; }
    button { padding: 6px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
  </style>
</head>
<body>
  <div id="box1" class="cell">1</div>
  <div id="box2" class="cell">2</div>
  <div id="box3" class="cell">3</div>
  <div id="box4" class="cell">4</div>

  <div class="hud">
    <label>EEG: <code id="eegVal">—</code></label>
    <label>Smoothed: <code id="smoothVal">—</code></label>
    <label>Baseline: <code id="baselineVal">—</code></label>
    <label>Threshold: <code id="threshVal">—</code></label>
    <button id="btnCal">Calibrate (30s)</button>
    <button id="btnSim">Sim: Off</button>
    <label>Cooldown(ms): <input id="cool" type="number" value="600" style="width:64px"></label>
    <label>Hysteresis: <input id="hyst" type="number" value="0.2" step="0.05" style="width:64px"></label>
  </div>

  <script>
    // ===== UI / cycling =====
    const cells = Array.from(document.querySelectorAll('.cell'));
    let idx = 0;
    cells[idx].classList.add('on');

    function cycle() {
      cells[idx].classList.remove('on');
      idx = (idx + 1) % cells.length;

      // Reset selections when wrapping to first cell (fresh lap)
      if (idx === 0) cells.forEach(c => c.classList.remove('selected'));

      cells[idx].classList.add('on');
    }
    const CYCLE_MS = 1250;
    setInterval(cycle, CYCLE_MS);

    // ===== EEG pipeline (hook your real signal into onEEG(value)) =====
    // Moving average smoothing (window N)
    const WINDOW = 10;
    const buf = [];
    let sum = 0;

    // Baseline + autodetected threshold
    let baseline = 0;
    let threshold = 0;

    // Edge detection with hysteresis + cooldown
    let armed = true;            // true means we are waiting for a rising edge
    let lastFire = 0;

    const elEEG = document.getElementById('eegVal');
    const elSmooth = document.getElementById('smoothVal');
    const elBase = document.getElementById('baselineVal');
    const elThresh = document.getElementById('threshVal');
    const elCool = document.getElementById('cool');
    const elHyst = document.getElementById('hyst');

    function onEEG(value) {
      // 1) show raw
      elEEG.textContent = value.toFixed(3);

      // 2) moving average
      buf.push(value);
      sum += value;
      if (buf.length > WINDOW) sum -= buf.shift();
      const smooth = sum / buf.length;
      elSmooth.textContent = Number.isFinite(smooth) ? smooth.toFixed(3) : '—';

      // 3) thresholds
      const coolMs = parseInt(elCool.value || '600', 10);
      const hyster = parseFloat(elHyst.value || '0.2');

      const upper = threshold;                 // cross above to trigger
      const lower = baseline + hyster * (threshold - baseline); // drop below to re-arm

      const now = performance.now();

      if (armed && smooth > upper && (now - lastFire) > coolMs) {
        // rising edge detected -> select current cell
        cells[idx].classList.add('selected');
        lastFire = now;
        armed = false;
        // Optional: if you want to lock the selection to the *previous* cell instead:
        // const prev = (idx - 1 + cells.length) % cells.length;
        // cells[prev].classList.add('selected');
      } else if (!armed && smooth < lower) {
        // fell back below lower band -> re-arm
        armed = true;
      }
    }

    // ===== Calibration: measure baseline for 1 sec and auto threshold =====
    document.getElementById('btnCal').addEventListener('click', () => {
      const samples = [];
      const t0 = performance.now();
      const dur = 30000; // 30s
      const handler = (v) => samples.push(v);

      // Attach a temporary tap into onEEG
      const origOnEEG = onEEG;
      window.onEEG = function(v) {
        handler(v);
        origOnEEG(v);
      };

      setTimeout(() => {
        // Restore
        window.onEEG = origOnEEG;

        if (samples.length) {
          // baseline = mean of smoothed-ish values
          const mean = samples.reduce((a,b)=>a+b,0) / samples.length;
          // robust spread estimate
          const med = samples.slice().sort((a,b)=>a-b)[Math.floor(samples.length/2)];
          const mad = samples.map(x => Math.abs(x - med)).sort((a,b)=>a-b)[Math.floor(samples.length/2)] || 0.001;

          baseline = mean;
          // threshold = baseline + k * MAD  (k=6 is a decent starting point)
          threshold = baseline + 6 * mad;

          elBase.textContent = baseline.toFixed(3);
          elThresh.textContent = threshold.toFixed(3);

          // Re-arm detector after calibration
          armed = true;
        }
      }, dur);
    });

    //Connecting to OpenBCI
    const ws = new WebSocket("ws://localhost:8080");
    ws.onmessage = (msg) => {
      const val = parseFloat(msg.data);
      if (!isNaN(val)) window.onEEG(val);
    };

    function startSim() {
      // Baseline ~ 1.0 ± noise, with occasional bursts upwards (as if “intent”)
      let t = 0;
      simTimer = setInterval(() => {
        t += 0.02;
        const noise = 0.05 * (Math.random() - 0.5);
        let v = 1.0 + 0.03*Math.sin(2*Math.PI*0.7*t) + noise;
        // Random burst
        if (Math.random() < 0.04) v += 0.6 + Math.random()*0.5;
        onEEG(v);
      }, 20); // 50 Hz stream
    }
    function stopSim() { clearInterval(simTimer); simTimer = null; }

    // Expose onEEG globally so you can feed real data: window.onEEG(value)
    window.onEEG = onEEG;

    // Optional: quick manual calibration at start of sim
    // (Click "Calibrate" after a second or two for a better baseline.)

    let simTimer = null;                 // <— you referenced this but never declared it
    const btnSim = document.getElementById('btnSim');

    btnSim.addEventListener('click', () => {
      if (simTimer) {
        stopSim();
        btnSim.textContent = 'Sim: Off';
      } else {
        startSim();
        btnSim.textContent = 'Sim: On';
      }
    });
  </script>
</body>
</html>
